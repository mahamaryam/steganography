THE REAL OG LOGIC.

EXPLANATION: LOGIC FOR CODE PART

 for i in range(len(binary_message)):
        pixel_index = i // 3  # Get the pixel index
        color_index = i % 3   # Get the color channel index (R,G,B)
        row = pixel_index // pixels.shape[1]
        col = pixel_index % pixels.shape[1]
        
        # Get the bit to encode
        bit = int(binary_message[i])
        
        # Get current pixel value
        pixel_value = int(encoded_pixels[row, col, color_index])
        
        # Clear LSB and set new bit
        if bit == 1:
            pixel_value = pixel_value | 1  # Set LSB to 1
        else:
            pixel_value = pixel_value & ~1  # Set LSB to 0
            
        # Ensure value stays within uint8 range
        pixel_value = np.clip(pixel_value, 0, 255)
        
        # Store modified pixel value
        encoded_pixels[row, col, color_index] = pixel_value



The logic in this code snippet is part of a **Least Significant Bit (LSB) Steganography** encoding process, where a binary message is embedded into the least significant bits of an image's pixel values. Let’s break it down step by step:

---

### **1. Loop Over Each Bit of the Message**
```python
for i in range(len(binary_message)):
```
- The `binary_message` is a string containing the binary representation of the message to be encoded (e.g., `"01100001"` for 'a').
- The loop iterates through each bit (`0` or `1`) in this binary message.

---

### **2. Identify the Target Pixel and Color Channel**
```python
pixel_index = i // 3  # Get the pixel index
color_index = i % 3   # Get the color channel index (R, G, B)
row = pixel_index // pixels.shape[1]
col = pixel_index % pixels.shape[1]
```
- Pixels in an RGB image consist of three channels (Red, Green, Blue). Therefore, each pixel can store up to 3 bits of the message (one in each channel).
- **Mapping the Bit to Pixel and Channel**:
  - `pixel_index = i // 3`: Determines which pixel to use for the current bit.
  - `color_index = i % 3`: Determines which channel (R, G, or B) within the pixel to modify for the current bit.
- **Mapping to 2D Image Coordinates**:
  - `row = pixel_index // pixels.shape[1]`: Calculates the row in the image where the pixel is located.
  - `col = pixel_index % pixels.shape[1]`: Calculates the column in the image where the pixel is located.

---

### **3. Extract the Current Bit to Encode**
```python
bit = int(binary_message[i])
```
- Retrieves the current bit (as an integer) from the binary message to be encoded into the image.

---

### **4. Access the Target Pixel’s Value**
```python
pixel_value = int(encoded_pixels[row, col, color_index])
```
- Extracts the pixel value for the specific color channel (`R`, `G`, or `B`) where the bit will be encoded.
- `encoded_pixels` is a modifiable copy of the original pixel array.

---

### **5. Modify the Least Significant Bit**
#### Clear the LSB:
```python
pixel_value = pixel_value & ~1
```
- The bitwise `AND` operation with `~1` clears the least significant bit of `pixel_value`. 
  - `~1` is the bitwise negation of `1` (binary `00000001`), resulting in `11111110`.
  - This operation ensures that the least significant bit is always `0`.

#### Set the LSB Based on the Message Bit:
```python
if bit == 1:
    pixel_value = pixel_value | 1
```
- If the message bit is `1`, the bitwise `OR` operation with `1` sets the least significant bit to `1`.

---

### **6. Ensure Valid Pixel Value**
```python
pixel_value = np.clip(pixel_value, 0, 255)
```
- Ensures the modified pixel value is within the valid range `[0, 255]`, although this is typically unnecessary for `uint8` operations.

---

### **7. Store the Modified Pixel Value**
```python
encoded_pixels[row, col, color_index] = pixel_value
```
- Updates the specific color channel (`R`, `G`, or `B`) of the target pixel with the modified value containing the embedded bit.

---

### **Key Insights**
1. **Encoding Logic**:
   - Each bit of the message is encoded in the LSB of a pixel channel, ensuring minimal alteration to the image.
   - By spreading the message across multiple pixels and channels, the visual impact is negligible.

2. **Pixel and Channel Mapping**:
   - The mapping logic ensures that bits are encoded sequentially across all pixels and channels in the image.

3. **Bitwise Operations**:
   - The `& ~1` and `| 1` operations effectively clear and set the LSB without disturbing other bits in the pixel value.

---

### **Example**
#### Input:
- Binary message: `"110"`
- Pixel array (3x3 RGB image):
  ```
  [[[200, 150, 100], [50, 25, 75], [30, 60, 90]],
   [[255, 200, 100], [0, 10, 20], [70, 80, 90]],
   [[5, 15, 25], [35, 45, 55], [65, 75, 85]]]
  ```

#### Encoding Process:
1. Encode `1` in the LSB of `200` (Red channel of pixel [0,0]):
   - Original: `200` (binary `11001000`)
   - Clear LSB: `11001000 & 11111110 = 11001000`
   - Set LSB: `11001000 | 00000001 = 11001001` → `201`

2. Encode `1` in the LSB of `150` (Green channel of pixel [0,0]):
   - Original: `150` (binary `10010110`)
   - Clear LSB: `10010110 & 11111110 = 10010110`
   - Set LSB: `10010110 | 00000001 = 10010111` → `151`

3. Encode `0` in the LSB of `100` (Blue channel of pixel [0,0]):
   - Original: `100` (binary `01100100`)
   - Clear LSB: `01100100 & 11111110 = 01100100`
   - No need to set: remains `100`.

#### Output Pixel:
`[201, 151, 100]`

Let's walk through how this indexing works with a concrete example. We'll assume a **binary message** and a small **image array**, and we'll calculate the pixel and channel for each bit being encoded.

---

### **Setup**
#### Binary Message:
Let’s encode the binary message:  
`binary_message = "101001"`

#### Image Array:
Suppose the image is a **3x3 RGB image**. Each pixel has three color channels (R, G, B). The array might look like this:
```python
pixels = np.array([
    [[200, 150, 100], [50, 25, 75], [30, 60, 90]],
    [[255, 200, 100], [0, 10, 20], [70, 80, 90]],
    [[5, 15, 25], [35, 45, 55], [65, 75, 85]]
])
pixels.shape  # (3, 3, 3)
```
- `pixels.shape[1] = 3` (Number of columns in the image).

#### Loop Logic:
We’ll iterate over each bit in the message and calculate:
1. **Pixel Index**: Determines which pixel stores the bit.
2. **Color Index**: Determines which color channel (R, G, or B) within the pixel stores the bit.
3. **Row and Column**: Maps the **pixel index** to the 2D image coordinates.
4. **Pixel Value**: Accesses the specific value in the pixel array.

---

### **Example Walkthrough**

#### Iteration 1 (`i = 0`):
1. **Get Pixel and Color Index**:
   - `pixel_index = i // 3 = 0 // 3 = 0`
   - `color_index = i % 3 = 0 % 3 = 0` (Red channel)

2. **Get Row and Column**:
   - `row = pixel_index // pixels.shape[1] = 0 // 3 = 0`
   - `col = pixel_index % pixels.shape[1] = 0 % 3 = 0`

3. **Access Pixel Value**:
   - `pixel_value = pixels[row, col, color_index] = pixels[0, 0, 0] = 200`

---

#### Iteration 2 (`i = 1`):
1. **Get Pixel and Color Index**:
   - `pixel_index = i // 3 = 1 // 3 = 0`
   - `color_index = i % 3 = 1 % 3 = 1` (Green channel)

2. **Get Row and Column**:
   - `row = pixel_index // pixels.shape[1] = 0 // 3 = 0`
   - `col = pixel_index % pixels.shape[1] = 0 % 3 = 0`

3. **Access Pixel Value**:
   - `pixel_value = pixels[row, col, color_index] = pixels[0, 0, 1] = 150`

---

#### Iteration 3 (`i = 2`):
1. **Get Pixel and Color Index**:
   - `pixel_index = i // 3 = 2 // 3 = 0`
   - `color_index = i % 3 = 2 % 3 = 2` (Blue channel)

2. **Get Row and Column**:
   - `row = pixel_index // pixels.shape[1] = 0 // 3 = 0`
   - `col = pixel_index % pixels.shape[1] = 0 % 3 = 0`

3. **Access Pixel Value**:
   - `pixel_value = pixels[row, col, color_index] = pixels[0, 0, 2] = 100`

---

#### Iteration 4 (`i = 3`):
1. **Get Pixel and Color Index**:
   - `pixel_index = i // 3 = 3 // 3 = 1`
   - `color_index = i % 3 = 3 % 3 = 0` (Red channel)

2. **Get Row and Column**:
   - `row = pixel_index // pixels.shape[1] = 1 // 3 = 0`
   - `col = pixel_index % pixels.shape[1] = 1 % 3 = 1`

3. **Access Pixel Value**:
   - `pixel_value = pixels[row, col, color_index] = pixels[0, 1, 0] = 50`

---

#### Iteration 5 (`i = 4`):
1. **Get Pixel and Color Index**:
   - `pixel_index = i // 3 = 4 // 3 = 1`
   - `color_index = i % 3 = 4 % 3 = 1` (Green channel)

2. **Get Row and Column**:
   - `row = pixel_index // pixels.shape[1] = 1 // 3 = 0`
   - `col = pixel_index % pixels.shape[1] = 1 % 3 = 1`

3. **Access Pixel Value**:
   - `pixel_value = pixels[row, col, color_index] = pixels[0, 1, 1] = 25`

---

#### Iteration 6 (`i = 5`):
1. **Get Pixel and Color Index**:
   - `pixel_index = i // 3 = 5 // 3 = 1`
   - `color_index = i % 3 = 5 % 3 = 2` (Blue channel)

2. **Get Row and Column**:
   - `row = pixel_index // pixels.shape[1] = 1 // 3 = 0`
   - `col = pixel_index % pixels.shape[1] = 1 % 3 = 1`

3. **Access Pixel Value**:
   - `pixel_value = pixels[row, col, color_index] = pixels[0, 1, 2] = 75`

---

### **Final Summary**

| **i** | **Pixel Index** | **Color Index** | **Row** | **Column** | **Channel** | **Pixel Value** |
|-------|-----------------|-----------------|---------|------------|-------------|-----------------|
| 0     | 0               | 0               | 0       | 0          | Red         | 200             |
| 1     | 0               | 1               | 0       | 0          | Green       | 150             |
| 2     | 0               | 2               | 0       | 0          | Blue        | 100             |
| 3     | 1               | 0               | 0       | 1          | Red         | 50              |
| 4     | 1               | 1               | 0       | 1          | Green       | 25              |
| 5     | 1               | 2               | 0       | 1          | Blue        | 75              |

This indexing logic ensures that bits are sequentially encoded into the image, spreading across pixels and color channels systematically.
